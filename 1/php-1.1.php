<!doctype html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport"
          content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>ДЗ 1</title>
</head>
<body>
    <?php
    /*
    php -v

    PHP 8.0.28 (cli) (built: Apr 26 2023 19:52:27) ( NTS DEBUG )
    Copyright (c) The PHP Group
    Zend Engine v4.0.28, Copyright (c) Zend Technologies
    with Zend OPcache v8.0.28, Copyright (c), by Zend Technologies
    */
    ?>
    <p>1 сделано</p>
    <p>2 сделано</p>
    <?php
    var_dump(3 / 1);
    ?>
    <p>3.1 - результат операции деления (3 / 1) число 3 с типом int.</p>
    <?php
    var_dump(1 / 3);
    ?>
    <p>3.2 - результат операции деления (1 / 3) число 0.3333333333333333 с типом float.</p>
    <?php
    var_dump('20cats' + 40);
    ?>
    <p>3.3 - результат операции сложения ('20cats' + 40) число 60 с типом int. В данной операции сложения, PHP попытался привести к числу левый операнд и получилось 20. Далее происходит операция сложения 2-х чисел 20 и 40.</p>
    <?php
    var_dump(18 % 4);
    ?>
    <p>3.3 - результат операции деления с остатком (18 % 4) число 2 с типом int.</p>
    <?php
    echo ($a = 2);
    ?>
    <p>4.1 - результатом присваивания переменной $a является число 2.</p>
    <?php
    $x = ($y = 12) - 8;
    echo $x;
    ?>
    <p>4.2 - результатом присваивания переменной $x является число 4. При операторе присваивания сначала выполняется правая часть инструкций. В правой части переменной $y
        присваивается 12, так как скобки указывают на принудительный порядок выполнения операторов. Далее с переменной $y происходит арифметическое действие
        вычитание, то есть 12 - 8 получается 4.</p>
    <?php
    var_dump(1 == 1.0);
    ?>
    <p>5.1 - результат сравнения логическое true типа bool. При операторе сравнения "==" (равно) левый и правый операнды сравниваются после преобразования типов.</p>
    <?php
    var_dump(1 === 1.0);
    ?>
    <p>5.2 - результат сравнения логическое false типа bool. При операторе сравнения "===" (Тождественно равно) левый (тип int) и правый (тип float) операнды сравниваются и должны быть одного типа.</p>
    <?php
    var_dump('02' == 2);
    ?>
    <p>5.3 - результат сравнения логическое true типа bool. При операторе сравнения "==" (равно) левый и правый операнды сравниваются после преобразования типов.</p>
    <?php
    var_dump('02' === 2);
    ?>
    <p>5.4 - результат сравнения логическое false типа bool. При операторе сравнения "===" (Тождественно равно) левый (тип string) и правый (тип int) операнды сравниваются и должны быть одного типа.</p>
    <?php
    var_dump('02' == '2');
    ?>
    <p>5.5 - результат сравнения логическое true типа bool. При операторе сравнения "==" (равно) левый и правый операнды сравниваются после преобразования типов.</p>
    <?php
    $x = true XOR true;
    var_dump($x);
    ?>
    <p>6 - результат присваивания переменной $x является логическое true типа bool. В данном случаи оператор присваивания "=" имеет приоритет выполнения над
        логическим оператором "xor", поэтому true. <br> Когда я посмотрел более внимательно документацию (https://www.php.net/manual/ru/language.operators.logical.php) и
        4-ю страницу слайда из 2-го занятия, я понял что в "true XOR true" должно быть false и задал себе вопрос, что же я не учёл. <br>И стал искать информацию в интернете и
        нашёл похожий пример объяснения на сайте https://puzzleweb.ru/php/15_logic.php про "xor". Это меня навело на мысль посмотреть приоритеты выполнения
        операторов https://www.php.net/manual/ru/language.operators.precedence.php (что в тексте сайта прямо и написано). Теперь я понял почему присвоилось "true".
    </p>
</body>
</html>
